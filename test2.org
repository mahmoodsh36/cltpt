:PROPERTIES:
:ID:       b94c1219-f8a3-44ac-b41b-81817e0c0f32
:END:
#+title: this is my title
#+image: %(get-lax-preview-svg-by-blk-id-1 "fig-graph-1")
#+name: test-name
#+more: here eee
\begin{equation}
my equation here
\end{equation}
#+begin_definition :defines standard thing :name def-ac-standard :something :something2
an \(\compAC\) circuit is a /standard \(\compAC\) circuit/ iff:
1. the circuit is divided into layers, such that edges only connect vertices between subsequent layers.
2. in each layer there are only \(\textbooland\) or \(\textboolor\) gates (except the input layer).
3. in subsequent layers there are only different types of gates (e.g. an AND layer is followed by an OR layer, and vice versa).
we say the circuit is /very standard/ if the indegree of each gate in the first (non-input) layer is at most \(2\log(S)\), where \(S\) is the size of the circuit.
#+end_definition

#+begin_question
wow

#+begin_answer
what
#+end_answer

#+begin_src latex :file (cached-file "P9jJoKl.svg") :cache yes
  \begin{alg}
    \SetKwFunction{func}{\textsc{Relax}}
    \fn{\func{G,u,v}} {
      $time\_passed \gets d[u]$\;
      $actual\_weight \gets \textsc{Google-Updated-Weight}(time\_passed, (u,v))$\;
      \If {$d[v] > d[u] + actual\_weight$} {
        $d[v] \gets d[u] + actual\_weight$\;
        $p[v] \gets u$\;
      }
    }
  \end{alg}
#+end_src
hey
#+end_question

#+mykeyword: value
some [[mylink1-2:here1][testmore1- 2]] text
[[attachment:sliding.gif]]
[[attachment:sliding]]

comment here
#+begin_comment
this is a comment
#+end_comment
\#+begin_comment
this is a comment 2
\#+end_comment

some \*text*
text *

some \~text~
text ~

latex here
\[ x = \sqrt{x^2} \]

code here
#+begin_src python :results output
  "this is a <test></test>"
  import requests
  print('whatever')
  print('whatever2')
#+end_src

#+RESULTS:
: whatever
: <test></test>
: whatever2
: \(11\)
: wow

#+begin_src python :results output
  do nothing
#+end_src

#+RESULTS[ca08ab2a6a58662675694033105ab0b331611fa2]:
[[file:~/brain/out/jyBtMrE.svg]]

\begin{dummy}
  this is a test
\end{dummy}

#+begin_definition :defines vector :name def-vector :exports none
hello definition.
#+end_definition

escaped macro here: \#(format nil "test~A" 1)

#(cltpt/base::make-block :type 'definition)
my first block
#(cltpt/base::block-end)

#(cltpt/base::make-block :type 'theorem :let '((a "some text")))
  my first block
  %a
  #(cltpt/base::make-block :type 'subtheorem
               :let* '((b " that will be included on export")))
    %(concatenate 'string a b)
  #(cltpt/base::block-end)
#(cltpt/base::block-end)

# start with #20

add 1 to get %(+ (cltpt/base::prev-obj-eval) 1), add 10 to get %(+ (cltpt/base::prev-obj-eval) 10)

#(cltpt/base::blk :type 'theorem
        :let '((prev-num (prev))
               (next-num (parse-integer (car (text-list-items (next 'text-list)))))
               (new-num (+ prev-num next-num))))
then add the first number from the next list to get %new-num
multiply that by 5 to get %(* new-num 5). anything is possible! this is only a simple example
#(cltpt/base::/blk)

- 45 [[mylink]]
- 45 \(mathhh\)
- 50
- 10

hi

- we have \(x=y\)
  a. nested item one
     more nested text
     1. test1
     2. test2
  b. nested item two
- item three

the /links/:

- org-mode link:                [[block1][next block]]
- link using our "text macros": #(ref :id "block1" :text "next block")
- markdown link:                ()[]

are equivalent, they point to the same object which is the next 'definition' block.

the specific functionality or syntax (like the org-mode link syntax above) can be enabled or
disabled as desired by the user. the parser is completely customizable and extensible,
we provide a default mode that parses /most/ of org-mode's syntax but it need not be used.
i personally plan on reducing my usage of org-mode syntax elements and use the "text-macro"
syntax above because it is a much more powerful alternative.

#(cltpt/base::b :type 'definition :name "block1" :let '((myvar1 ")my(-(test)")))
output: %(concatenate 'string "value: [[[" myvar1 "]]]").
#(cltpt/base::/b)

to transclude some block (possibly from another file ofcourse):
#(transclude :name "block1" :rebind '((myvar1 "somevaluehere")))

here is *some important text*, but also more *important text*.
also *more*. but more*

some ~inline code~ here.

some /italicized text/ here, and some ~code~ here.

tables
| code                             | math                  |
|----------------------------------+-----------------------|
| ~layer-x\9*1*0~                  | \(I^\ell\)            |
| ~layer-y~                        | \(\hat Y^\ell\)       |
| ~layer-y-unactivated~            | \(S^\ell\)            |
| ~s-deltas~                       | \(\Delta S^\ell\)     |
| ~x-deltas~                       | \(I^\ell\)            |
| ~activation-function~            | \(\phi\)              |
| ~activation-function-derivative~ | \(\phi'\)             |
| ~propped-deltas~                 | \(\Delta I^{\ell+1}\) |
| ~learning-rate~                  | \(\alpha\)            |


| head1   | head2 | head3 |
|---------+-------+-------|
| foo     |       | baz   |
| 123     | 456   | 789   |
| \(x=y\) |       |       |
|         |       |       |
| end     | row   | test  |


\( more math \)

#+begin_export html
<p style="color: red;">this should only be visible in the html export</p>
#+end_export

#+begin_src python :results file :var filepath=(cached-file "WRB4q2d.svg") :exports results
  import matplotlib
  matplotlib.use('Agg')
  import matplotlib.pyplot as plt
  import matplotlib.patches as patches
  import numpy as np

  def draw_circle(ax, center, radius, label):
      """Helper function to draw a circle for a node."""
      circle = patches.Circle(center, radius, facecolor='white', edgecolor='black', lw=2, zorder=3)
      ax.add_patch(circle)
      ax.text(center[0], center[1], label, ha='center', va='center', fontsize=16, fontweight='bold', zorder=4)

  def draw_triangle(ax, top_vertex, width, height, label):
      """Helper function to draw a triangle for a subtree, positioned by its top vertex."""
      x, y = top_vertex
      vertices = np.array([[x - width / 2, y - height], [x + width / 2, y - height], [x, y]])
      triangle = patches.Polygon(vertices, closed=True, facecolor='white', edgecolor='black', lw=2, zorder=3)
      ax.add_patch(triangle)
      ax.text(x, y - height * 0.6, label, ha='center', va='center', fontsize=16, zorder=4)

  def draw_edge_line(ax, center1, center2, r1, r2):
      """Helper function to draw a line between the edges of two shapes."""
      x1, y1 = center1
      x2, y2 = center2
      dx, dy = x2 - x1, y2 - y1
      dist = np.sqrt(dx**2 + dy**2)
      
      if dist == 0: return
      
      start_x = x1 + r1 * (dx / dist)
      start_y = y1 + r1 * (dy / dist)
      end_x = x2 - r2 * (dx / dist)
      end_y = y2 - r2 * (dy / dist)
      
      ax.plot([start_x, end_x], [start_y, end_y], 'k-', lw=2, zorder=1)

  # --- Main Script ---
  fig, ax = plt.subplots(figsize=(16, 6))
  ax.set_aspect('equal')
  ax.axis('off')

  # Common parameters
  radius = 0.7
  tri_width = 2.5
  tri_height = 1.5

  # --- Tree 1 ---
  z1_pos = (5, 10)
  y1_pos = (7.5, 7)
  x1_pos = (10, 4)
  alpha1_pos = (3, 8)
  beta1_pos = (5.5, 5)
  gamma1_pos = (8, 2)
  delta1_pos = (12, 2)

  draw_edge_line(ax, z1_pos, y1_pos, radius, radius)
  draw_edge_line(ax, z1_pos, alpha1_pos, radius, 0)
  draw_edge_line(ax, y1_pos, x1_pos, radius, radius)
  draw_edge_line(ax, y1_pos, beta1_pos, radius, 0)
  draw_edge_line(ax, x1_pos, gamma1_pos, radius, 0)
  draw_edge_line(ax, x1_pos, delta1_pos, radius, 0)

  draw_circle(ax, z1_pos, radius, 'z')
  draw_circle(ax, y1_pos, radius, 'y')
  draw_circle(ax, x1_pos, radius, 'x')
  draw_triangle(ax, alpha1_pos, tri_width, tri_height, 'α')
  draw_triangle(ax, beta1_pos, tri_width, tri_height, 'β')
  draw_triangle(ax, gamma1_pos, tri_width, tri_height, 'γ')
  draw_triangle(ax, delta1_pos, tri_width, tri_height, 'δ')

  # --- Tree 2 ---
  y2_pos = (20.5, 10)
  z2_pos = (17, 7)
  x2_pos = (24, 7)
  alpha2_pos = (15, 5)
  beta2_pos = (19, 5)
  gamma2_pos = (22, 5)
  delta2_pos = (26, 5)

  draw_edge_line(ax, y2_pos, z2_pos, radius, radius)
  draw_edge_line(ax, y2_pos, x2_pos, radius, radius)
  draw_edge_line(ax, z2_pos, alpha2_pos, radius, 0)
  draw_edge_line(ax, z2_pos, beta2_pos, radius, 0)
  draw_edge_line(ax, x2_pos, gamma2_pos, radius, 0)
  draw_edge_line(ax, x2_pos, delta2_pos, radius, 0)

  draw_circle(ax, y2_pos, radius, 'y')
  draw_circle(ax, z2_pos, radius, 'z')
  draw_circle(ax, x2_pos, radius, 'x')
  draw_triangle(ax, alpha2_pos, tri_width, tri_height, 'α')
  draw_triangle(ax, beta2_pos, tri_width, tri_height, 'β')
  draw_triangle(ax, gamma2_pos, tri_width, tri_height, 'γ')
  draw_triangle(ax, delta2_pos, tri_width, tri_height, 'δ')

  # --- Tree 3 ---
  x3_pos = (36, 10)
  y3_pos = (33.5, 7)
  z3_pos = (31, 4)
  alpha3_pos = (29, 2)
  beta3_pos = (33, 2)
  gamma3_pos = (35.5, 5)
  delta3_pos = (38, 8)

  draw_edge_line(ax, x3_pos, y3_pos, radius, radius)
  draw_edge_line(ax, x3_pos, delta3_pos, radius, 0)
  draw_edge_line(ax, y3_pos, z3_pos, radius, radius)
  draw_edge_line(ax, y3_pos, gamma3_pos, radius, 0)
  draw_edge_line(ax, z3_pos, alpha3_pos, radius, 0)
  draw_edge_line(ax, z3_pos, beta3_pos, radius, 0)

  draw_circle(ax, x3_pos, radius, 'x')
  draw_circle(ax, y3_pos, radius, 'y')
  draw_circle(ax, z3_pos, radius, 'z')
  draw_triangle(ax, alpha3_pos, tri_width, tri_height, 'α')
  draw_triangle(ax, beta3_pos, tri_width, tri_height, 'β')
  draw_triangle(ax, gamma3_pos, tri_width, tri_height, 'γ')
  draw_triangle(ax, delta3_pos, tri_width, tri_height, 'δ')

  # Final plot adjustments
  plt.ylim(0, 12)
  plt.xlim(0, 40)

  # Save the figure to an SVG file
  plt.savefig(filepath, format="svg", bbox_inches='tight', pad_inches=0.1)
  plt.close() # Close the plot to free up memory
  return filepath
#+end_src

#+RESULTS:
[[file:/home/mahmooz/brain/out/WRB4q2d.svg]]

test more
* TODO task 1
<2025-10-14 Tue>
* TODO task 2
DEADLINE: <2025-10-13 Mon 13:00:00>
* TODO task 3
<2025-10-11 Sat 10:00:00 +1w>--<2025-10-11 Sat 14:00:00 +1w>